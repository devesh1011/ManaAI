"""
In this file we have some utility functions for checking and correcting the react code generated by the explainer agent
"""
import re
import subprocess
import json
import tempfile
import os
import shutil

plugin_imports = """
import * as Recharts from 'recharts';
import React from "react";
import 'katex/dist/katex.min.css';
import Latex from 'react-latex-next';
import Plot from 'react-plotly.js';
import SyntaxHighlighter from 'react-syntax-highlighter';
import { dark } from 'react-syntax-highlighter/dist/esm/styles/hljs'
import * as RF from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import { motion } from "motion/react"
"""

def find_react_code_in_response(text: str) -> str:
    """
    Extracts React component code from a text response.
    Handles nested components, complex JSX, and various React patterns.

    Returns the first complete React component found, or None if no valid component is detected.
    """

    def is_jsx_element(s):
        """Check if string contains JSX elements"""
        jsx_patterns = [
            r'<[A-Z][a-zA-Z0-9]*[^>]*>',  # Component tags like <MyComponent>
            r'<[a-z]+[^>]*>',  # HTML tags like <div>, <span>
            r'<[^>]+\s*/>',  # Self-closing tags like <img />
            r'{\s*[^}]*\s*}',  # JSX expressions like {variable}
        ]
        return any(re.search(pattern, s) for pattern in jsx_patterns)

    def extract_balanced_braces(text, start_pos):
        """Extract content within balanced braces starting from start_pos"""
        if start_pos >= len(text) or text[start_pos] != '{':
            return None, start_pos

        brace_count = 0
        i = start_pos

        while i < len(text):
            char = text[i]
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    return text[start_pos:i + 1], i + 1
            i += 1

        return None, start_pos  # Unmatched braces

    def extract_function_body(text, start_pos):
        """Extract complete function body including parameters and body"""
        # Find the opening brace of the function
        brace_pos = text.find('{', start_pos)
        if brace_pos == -1:
            return None

        # Extract the balanced content
        body, end_pos = extract_balanced_braces(text, brace_pos)
        if body is None:
            return None

        # Include everything from start_pos to end_pos
        return text[start_pos:end_pos]

    # Patterns to identify React components
    react_patterns = [
        # Arrow functions: () => {}, (props) => {}, ({prop1, prop2}) => {}
        (r'(\([^)]*\)\s*=>\s*\{)', r'\([^)]*\)\s*=>\s*\{'),

        # Function declarations: function ComponentName() {}, function() {}
        (r'(function\s+[A-Z][a-zA-Z0-9]*\s*\([^)]*\)\s*\{)', r'function\s+[A-Z][a-zA-Z0-9]*\s*\([^)]*\)\s*\{'),
        (r'(function\s*\([^)]*\)\s*\{)', r'function\s*\([^)]*\)\s*\{'),

        # Const/let/var assignments: const Component = () => {}, const Component = function() {}
        (r'(const\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{)',
         r'const\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{'),
        (r'(const\s+[A-Z][a-zA-Z0-9]*\s*=\s*function\s*\([^)]*\)\s*\{)',
         r'const\s+[A-Z][a-zA-Z0-9]*\s*=\s*function\s*\([^)]*\)\s*\{'),
        (r'(let\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{)', r'let\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{'),
        (r'(var\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{)', r'var\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{'),

        # Export statements: export default () => {}, export const Component = () => {}
        (r'(export\s+default\s+\([^)]*\)\s*=>\s*\{)', r'export\s+default\s+\([^)]*\)\s*=>\s*\{'),
        (r'(export\s+const\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{)',
         r'export\s+const\s+[A-Z][a-zA-Z0-9]*\s*=\s*\([^)]*\)\s*=>\s*\{'),
    ]

    # Look for direct JSX without function wrapper
    jsx_direct_pattern = r'(<[A-Z][a-zA-Z0-9]*[^>]*>.*?</[A-Z][a-zA-Z0-9]*>|<[a-z]+[^>]*>.*?</[a-z]+>|<[^>]+\s*/>)'

    candidates = []

    # First, try to find function-based components
    for full_pattern, match_pattern in react_patterns:
        for match in re.finditer(match_pattern, text, re.DOTALL | re.IGNORECASE):
            start_pos = match.start()

            # Extract the complete function
            complete_function = extract_function_body(text, start_pos)
            if complete_function and is_jsx_element(complete_function):
                candidates.append((start_pos, complete_function))

    # Also look for direct JSX (might be just JSX without function wrapper)
    for match in re.finditer(jsx_direct_pattern, text, re.DOTALL):
        jsx_content = match.group(1)
        if is_jsx_element(jsx_content):
            candidates.append((match.start(), jsx_content))

    # Return the first (earliest in text) valid React component
    if candidates:
        candidates.sort(key=lambda x: x[0])  # Sort by position in text
        return candidates[0][1]

    return None

class ESLintValidator:
    """A class to validate JSX code using ESLint in a self-contained Node.js environment."""

    def __init__(self, eslint_base_dir=None):
        """
        Initializes the validator.

        Args:
            eslint_base_dir: Directory containing pre-installed ESLint setup.
                           If None, will look for it in common locations.
        """
        self.script_dir = os.path.dirname(os.path.realpath(__file__))

        # Try to find the pre-installed ESLint directory
        if eslint_base_dir:
            self.eslint_base_dir = eslint_base_dir
        else:
            # Check common locations
            possible_locations = [
                '/opt/eslint-setup',  # Docker location
                os.path.join(self.script_dir, 'eslint-setup'),  # Local development
                self.script_dir  # Fallback to current directory
            ]

            self.eslint_base_dir = None
            for location in possible_locations:
                if (os.path.exists(os.path.join(location, 'package.json')) and
                        os.path.exists(os.path.join(location, 'eslint.config.js')) and
                        os.path.exists(os.path.join(location, 'node_modules'))):
                    self.eslint_base_dir = location
                    print(f"Found node project in {location}")
                    break

            if not self.eslint_base_dir:
                raise FileNotFoundError(
                    f"Could not find pre-installed ESLint setup in any of: {possible_locations}"
                )

        # Verify required files exist
        self.config_file_path = os.path.join(self.eslint_base_dir, 'eslint.config.js')
        self.package_json_path = os.path.join(self.eslint_base_dir, 'package.json')
        self.node_modules_path = os.path.join(self.eslint_base_dir, 'node_modules')
        self.eslint_executable = os.path.join(self.node_modules_path, '.bin', 'eslint')

        for required_path in [self.config_file_path, self.package_json_path,
                              self.node_modules_path, self.eslint_executable]:
            if not os.path.exists(required_path):
                raise FileNotFoundError(f"Required file/directory not found: {required_path}")

        # Create a temporary directory for JSX files (reused across validations)
        self.temp_jsx_dir = os.path.join(self.eslint_base_dir, 'temp_jsx_files')
        os.makedirs(self.temp_jsx_dir, exist_ok=True)

    def validate_jsx(self, jsx_code: str):
        """
        Validates JSX using NamedTemporaryFile in a specific directory.
        """
        cleaned_code = find_react_code_in_response(jsx_code)

        if not cleaned_code:
            return {
                'valid': False,
                'errors': [{'message': 'Your response does not match the required format. Start your response with () and end with }'}]
            }
        
        code_with_imports = plugin_imports + "\n" + cleaned_code

        # Create temporary file in our designated directory
        with tempfile.NamedTemporaryFile(
                mode='w',
                suffix='.jsx',
                prefix='eslint_temp_',
                dir=self.temp_jsx_dir,
                delete=False,  # We'll delete manually after ESLint runs
                encoding='utf-8'
        ) as temp_file:
            temp_file.write(code_with_imports)
            temp_file_path = temp_file.name

        try:
            # Set up environment
            eslint_env = os.environ.copy()
            eslint_env['HOME'] = '/home/app'

            # Run ESLint
            lint_process = subprocess.run([
                self.eslint_executable,
                '--quiet',
                '--format', 'json',
                '--config', self.config_file_path,
                temp_file_path
            ],
                capture_output=True,
                text=True,
                cwd=self.eslint_base_dir,
                env=eslint_env,
                check=False
            )

            if lint_process.stdout:
                return self._parse_eslint_output(lint_process.stdout)

            return {
                'valid': False,
                'errors': [{'message': lint_process.stderr.strip()}] if lint_process.stderr else []
            }

        except (OSError, RuntimeError) as e:
            return {'valid': False, 'errors': [{'message': f"An unexpected error occurred: {str(e)}"}]}

        finally:
            # Clean up
            try:
                os.remove(temp_file_path)
            except OSError:
                pass

    def _parse_eslint_output(self, eslint_json_output):
        # This parsing logic remains the same
        try:
            data = json.loads(eslint_json_output)
            if not data:
                return {'valid': True, 'errors': [], 'warnings': []}

            file_report = data[0]
            if "fatal" in file_report and file_report["fatal"]:
                return {'valid': False, 'errors': [file_report.get('message', 'Fatal ESLint error')]}

            messages = file_report.get('messages', [])
            errors = [msg for msg in messages if msg.get('severity') == 2]
            warnings = [msg for msg in messages if msg.get('severity') == 1]

            return {
                'valid': len(errors) == 0,
                'errors': errors,
                'warnings': warnings
            }
        except (json.JSONDecodeError, IndexError):
            return {
                'valid': False,
                'errors': [{'message': f"Failed to parse ESLint output: {eslint_json_output}"}]
            }

import re


def clean_up_response(code_string):
    """
    Comprehensive function header removal
    Handles arrow functions, regular functions, and function expressions
    """
    code_string = find_react_code_in_response(code_string)

    # Clean up any extra whitespace
    code_string = code_string.strip()

    patterns = [
        # Arrow functions: () => {, (props) => {, ({prop1, prop2}) => {
        r'^\s*\([^)]*\)\s*=>\s*\{',

        # Regular functions: function() {, function name() {
        r'^\s*function\s*[a-zA-Z_$][a-zA-Z0-9_$]*\s*\([^)]*\)\s*\{',
        r'^\s*function\s*\([^)]*\)\s*\{',

        # Function expressions: const name = () => {, const name = function() {
        r'^\s*const\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*\([^)]*\)\s*=>\s*\{',
        r'^\s*const\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*function\s*\([^)]*\)\s*\{',

        # Let/var variations
        r'^\s*let\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*\([^)]*\)\s*=>\s*\{',
        r'^\s*var\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*=\s*\([^)]*\)\s*=>\s*\{',
    ]

    for pattern in patterns:
        if re.match(pattern, code_string):
            return re.sub(pattern, '', code_string).strip()

    return code_string.strip()

#--- TEST CASES ---
def code_test():
    # Example of code with a linting error (double quotes)
    jsx_code_with_error = """
    I am an idiot and dumb
    import React from 'react';
    () => { return (<div>Hello World<div>) };
"""

    # Example of valid code
    jsx_code_correct = """
    () => { return <div>Hello World</div> }};
    """

    validator = ESLintValidator()

    print("--- Validating code with a linting error ---")
    result_error = validator.validate_jsx(jsx_code_with_error)
    print(json.dumps(result_error, indent=2))

    print("\n--- Validating correct code ---")
    result_correct = validator.validate_jsx(jsx_code_correct)
    print(json.dumps(result_correct, indent=2))

if __name__ == "__main__":
    code_test()